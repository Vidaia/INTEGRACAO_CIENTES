## Integra√ß√£o com a TRIER - lambda functions

Essa aplica√ß√£o resolveu o problema de integra√ß√£o com clientes que utilizam o **<a href='https://triersistemas.com.br/?gad_source=1&gclid=CjwKCAiA6t-6BhA3EiwAltRFGOdYZhulFdY-30uQCrFWNRx4oONkGO_z6abSxsWVmkebeifzcz57ThoCPp4QAvD_BwE'>TRIER</a> ERP**, onde antes da solu√ß√£o era necess√°rio fazer a conex√£o remotamente ao computador do cliente, exportar todos os relat√≥rios manualmente, process√°-los e subir para o banco, agora temos uma API direta da trier onde o python consome, faz todos os processamentos necess√°rios e sobe para o banco, esse script roda diariamente no **<a href='https://aws.amazon.com/pt/pm/lambda/?gclid=CjwKCAiA6t-6BhA3EiwAltRFGBwC-XIXzETxYu-MC2FfAjPDKrvYBPbcbSFeDb5If4olhrCAgUhYcxoCxc4QAvD_BwE&trk=56f58804-91cd-4af4-98d4-afe277a57fd3&sc_channel=ps&ef_id=CjwKCAiA6t-6BhA3EiwAltRFGBwC-XIXzETxYu-MC2FfAjPDKrvYBPbcbSFeDb5If4olhrCAgUhYcxoCxc4QAvD_BwE:G:s&s_kwcid=AL!4422!3!651510591822!e!!g!!aws%20lambda!19828231347!148480170233'>aws lambda</a>**

A estrutura de pastas foi feita da seguinte forma:
```CMD
üìÇ - LAMBDA
üìÑ - lambda_function.py (arquivo principal que chama todas as fun√ß√µes)
üìÇ - utils
    |üìÑ - arrumar_json_itens.py (corrige o formato que vem os dados)
    |üìÑ - numero_telefone.py (corrige o telefone para o formato (DDI) DDD + X XXXX-XXXX)
    |üìÑ - TRIER.py (Arquivo "principal" onde s√£o feitas as requisi√ß√µes para a TRIER, juntamente com as tratativas para os dados)
    |üìÑ - ultima_compra.py (Pega o √∫ltimo registro de compra de um cliente)
üêã - Dockerfile
üìÑ - requirements.txt (bibliotecas necess√°rias)
```

### TRIER

> Acesse a [documenta√ß√£o oficial](https://homologacao.triersistemas.com.br/api-sgf/#) para mais informa√ß√µes sobre a integra√ß√£o.

Para acessar a API da trier, √© necess√°rio entrar em contato com a empresa solicitando um token de acesso para o cliente desejado, ap√≥s isso, basta importar o <a href='https://homologacao.triersistemas.com.br/api-sgf/postman-api-integracao-trier-1.5.4.json'>arquivo de requisi√ß√µes</a> no postman (ou em algum servi√ßo parecido) e testar a conex√£o.

Para rodar o arquivo principal, antes √© necess√°rio criar um arquivo com vari√°veis de ambiente, seguindo o exemplo abaixo:

```CMD
URL_CLIENTE_API: (/cliente/obter-todos-v1)
URL_PRODUTO_API:  (/produto/obter-todos-v1)
URL_VENDA_API: (/venda/obter-v1)

QTD_REGISTROS: (numero m√°ximo √© "999")
API_TOKEN_CONCEITO: (token da farm√°cia conceito (disponibilizado pela TRIER))
API_TOKEN_FARMAXI: (token da farm√°cia farmaxo (disponibilizado pela TRIER))
API_TOKEN_PORTAO: (token da farm√°cia port√£o (disponibilizado pela TRIER))

# link para o banco do X
host_X: 
port_X:  
database_X:  
user_X:  
password_X:  

# link para o banco do CRM
host_crm:  
port_crm:  
database_crm:  
user_crm:
password_crm:  
```

---

## Demais integra√ß√µes
> A documenta√ß√£o a seguir foi reaproveitada de um projeto antigo que integrava a vidaia a outros ERP's.

##### DIFERENTES SISTEMAS
<p style="text-align: justify;">
Atualmente temos 4 ERP's principais encontradas em nossos clientes:
</p>

- SPA
- TRIER
- SYSFAR
- LINX

<p style="text-align: justify;">
A aplica√ß√£o busca viabilizar a automatiza√ß√£o desse fluxo de extra√ß√£o e inser√ß√£o sem depender de um esfor√ßo humano, por mais que em uma pequena parte desse fluxo seja exigida um pr√©-processamento nos arquivos .XLSX, mas √© algo que pode ser melhorado posteriormente. A seguir voc√™ encontrar√° um pequeno review sobre cada ERP com suas qualidades de dificuldades, pode ser que nesse momento seja meio dificil de entender, mas ao final desse documento espero sanado as lacunas que ficar√£o ao decorrer dele.
</p>

<h4> COMO A EXTRA√á√ÉO √â FEITA HOJE?</h4>

Cada cliente tem em sua m√°quina um programa chamado Parsec, mas que poderia ser qualquer outro desde que permita o acesso remoto e o controle do mouse e teclado. O motivo da escolha do parsec foi a facilidade, o programa √© bem intuitivo, n√£o houve dificuldade por parte dos clientes em liberar o acesso a m√°quina, temos um v√≠deo tuturial de como instalar o parsec e logar na conta da vidaia, basta clicar [aqui](https://www.youtube.com/watch?v=PehEtd4CqS4) para assistir.


![SQL SPA](README_ASSETS/parsec.png)

<h4> MAPEAMENTO DOS ERP'S </h4>

**SPA:** Atualmente √© o ERP de maior facilidade, temos acesso direto ao SQL do cliente, possibilitando a extra√ß√£o de dados atrav√©s de um SELECT simples √†s tabelas *clientes*, *produtos* e a view *vendas_ger*. Felizmente temos 2 clientes que utilizam esse sistema, s√£o eles *Flores* e *Nostra Farma*.

<blockquote style="background-color: rgba(255, 255, 0, 0.8); color: black; padding: 10px; border-radius: 10px;">
    <b>ATEN√á√ÉO: O BANCO DA FLORES EST√Å LIBERADO SOMENTE PARA A NOSSA M√ÅQUINA EC2, SENDO ASSIM, A EXTRA√á√ÉO FOI FEITA MANUALMENTE E COLOCADA NA SUA DEVIDA PASTA DENTRO DE "DATA", UMA IMPLEMENTA√á√ÉO FUTURA SERIA ESSE SSH DIRETO NO C√ìDIGO
</blockquote>

![SQL SPA](README_ASSETS/SPA.png)

**SYSFAR:** De longe o nosso sistema mais problem√°tico, relat√≥rios sem rela√ß√£o, muita dificuldade em estruturar e subir tudo.

[clientes](https://docs.google.com/spreadsheets/d/1PC8D5aJXnnmHw97-kEwq_UO65b_OpFozPVpcdRV3TwU/edit?usp=sharing) - Dentre as exigidas, clientes √© a mais normal, apresenta tudo o que a gente precisa.

[produtos (c√≥digo de barras)](https://docs.google.com/spreadsheets/d/11KNdvFWhCPYPLJEkep4MjBsyM6tUwSBG2UZftyZ7NV0/edit?usp=sharing) - √â um arquivo o nome e o c√≥digo de barras do produto para realizar o merge com a tabela de produtos (que por alguma raz√£o n√£o possui o c√≥digo de barras)

[produtos](https://docs.google.com/spreadsheets/d/1gGLyWQSNbPjXiaOsUPJjI-Js0vjsypW8Bi0NwCJtBR8/edit?usp=sharing) - Aqui voc√™ contra todas as informa√ß√µes sobre os produtos, o √∫nico processamento foi adicionar o nome das colunas e uma pequena corre√ß√£o no alinhamento delas, voc√™ pode comparar as altera√ß√µes observando a primeira e a √∫ltima p√°gina.

[vendas]() - Foi o principal problema encontrado, realizamos a extra√ß√£o de uma tabela que aparentava ser as vendas di√°rias, realmente era, mas n√£o tinha um c√≥digo de rela√ß√£o entre clientes e o n√∫mero de venda considerado foi a coluna **NF**, realizei uma nova conex√£o no computador da cliente para tentar encontrar uma tabela de vendas que suprisse as necessidades, mas sem sucesso, contatamos o suporte e para ter acesso direto ao BD, estamos aguardando o retorno.

**LINX:** O ERP do cliente disponibilizou um usu√°rio com permiss√£o de consulta ao banco de dados, mas sem nenhum tipo de suporte referente ao significado das centenas de tabelas, realizamos a extra√ß√£o naquelas que julgamos √∫til. O lado bom √© que nenhum pr√©-processamento foi necess√°rio, basta jogar na pasta de dados da cia da sa√∫de que o script funciona-r√°.
[cliente](https://docs.google.com/spreadsheets/d/15RoZ2hFya3zOpH_I-Ws6wtJz0OzbC7ktST9c1SwdMRU/edit?usp=sharing) - Cadcli, parece meio estranha abrindo pelo sheets, mas √© s√≥ trocar o separador no python que ele abre certinho. 

[produtos](https://docs.google.com/spreadsheets/d/1Bi65r3m1isPUGw0OhdBNU2QvsmApxixCI1I8LG5x79k/edit?usp=sharing) - Estcad, tudo certinho, sem modifica√ß√µes.

[vendas](https://docs.google.com/spreadsheets/d/1HLqC07oTqUdoantqjGgKApXSoLjxWfSSTCbcP14xPs4/edit?usp=sharing) - Estped, uma das tabelas de vendas, sem modifica√ß√µes, apenas um merge com a outra tabela de vendas.

[vendas2](https://docs.google.com/spreadsheets/d/1zE5ZtbkehvIAv4VIzMJG1yjV959bK3DntvwhBnXSm1M/edit?usp=sharing) - Estped1, outra tabela com vendas, fizemos a jun√ß√£o com a tabela de cima.





<h4>SOBRE O C√ìDIGO</h4>

<p style="text-align: justify;">
Na pasta root do projeto temos 3 arquivos principais, s√£o eles *main.py*, *strategy.py* e *.env (apagado devido ao gitgnore)*. O programa foi todo desenvolvido em python adotando o design pattern Strategy que pode n√£o est√° perfeito pois essa foi uma das primeiras vezes
 Come√ßando pelo mais simples, o **.env** armazena as credenciais do banco da *flores*, *nostra farma* e do banco CRM da *vidaia*, deve ser recriado do seguinte formato:
</p>

 ```python
    user_flores = ''
    password_flores = ''
    host_flores = ''
    database_flores = ''
    port_flores = ''

    user_nostrafarma = ''
    password_nostrafarma = ''
    host_nostrafarma = ''
    database_nostrafarma = ''
    port_nostrafarma = ''

    host_vidaia = ''
    port_vidaia = ''
    database_vidaia = ''
    user_vidaia = ''
    password_vidaia = ''
 ```

<p style="text-align: justify;">
 Abrindo o arquivo <i style="color: #0000FF">main.py</i>, podemos ver que h√° um <b>try</b> para cada cliente, essa parte ainda est√° bem desorganizada, mas por l√° √© poss√≠vel verificar o tratamento individual relacionado a cada cliente antes de rodar o script.
 No <i style="color: #0000FF">strategy.py</i> voc√™ encontrar√° uma classe para cada ERP seguido das fun√ß√µes para o tratamento de cada tipo de dado, no final, teremos os seguintes dataframes para cada ERP:
</p>
<br>

<h6>Clientes</h6>
<p style="text-align: justify;">
para cada cliente √© um tratamento diferente, acessando a classe de cada ERP √© poss√≠vel observar mudan√ßas como: tipo de dado, tratamento de nulos, substitui√ß√µes feitas em strings, tratamento para o n√∫mero de telefone, tratamento para a √∫ltima compra etc, o dataframe final deve seguir o seguinte formato para todos os ERP's: 
</p>

 ```python
dfClientes = pd.DataFrame({
    "usuarioId" : self.usuario_id,
    "telefone" : self.consulta_clientes[''],
    "telefone2" : self.consulta_clientes[''],
    "telefone3" : self.consulta_clientes[''],
    "nome" : self.consulta_clientes[''],
    "cpf" : self.consulta_clientes[''],
    "endereco": self.consulta_clientes[''],
    "CEP": self.consulta_clientes[''],
    "numero": self.consulta_clientes[''],
    "codigoCliente" : self.consulta_clientes[''],
    "ultimaCompra" : self.consulta_clientes[''],
    "dataNascimento" : self.consulta_clientes[''],
    "clienteDesde" : self.consulta_clientes[''],
    'updatedAt' : datetime.now()
    })
 ```

<p style="text-align: justify;">
Como mencionado anteriormente, a fun√ß√£o processar_clientes() tem alguns processamentos, dentre eles os mais importantes s√£o: adicionar DDD ao telefone e verificar √∫ltima compra do cliente, na fun√ß√£o execute() de cada classe, √© poss√≠vel ver a ordem de execu√ß√£o de cada tratamento, come√ßando na maior parte das vezes pela venda, pois assim conseguimos dar um merge com clientes e verificar sua √∫ltima compra atrav√©s da fun√ß√£o ultima_compra() encontrado no arquivo <i style="color: #0000FF">ultima_compra.py</i> encontrado na pasta utils. Essa fun√ß√£o basicamente percorre o dataframe de vendas e bate com o ID do cliente, pegando o √∫ltimo registro desse cliente na tabela de vendas.

Outra fun√ß√£o bem importante √© a de adicionar o DDD a cada cliente, se observar o construtor de cada classe ERP podemos ver que ele recebe esse dado de DDD juntamente ao user_id que √© encontrado no nosso banco de CRM na tabela <i>users</i>, esse n√∫mero vem de conversas com o cliente para saber onde se localiza a farm√°cia, essa etapa √© bem importante para a parte de API do whatsapp, o dataframe de clientes passa pela fun√ß√£o <i>processar_colunas_por_telefone()</i> no arquivo <i style="color: #0000FF">processar_colunas_por_telefone.py</i> na pasta utils.

O resto do processamento √© particular para cada ERP, para mais informa√ß√µes, leia o c√≥digo.
</p>

<br>

<h6>Produtos Vidaia</h6>
<p style="text-align: justify;">
 Essa ainda √© uma tabela que estamos trabalhando, no momento ela √© basicamente um espelho da tabela de produtos, mas com informa√ß√µes diferentes relacionadas a cada um, seu objetivo √© ser uma tabela relacional com os produtos oriundos das extra√ß√µes dos clientes, ela dever√° possuir informa√ß√µes como grupo, fabricante, categoria etc. Visando diminuir o espa√ßo utilizado por produtos no geral no nosso banco, o principal impedimento √© a dificuldade em relacionar as duas devido a anormalidade encontrada no √∫nico ID que difere um produto do outro que seria o c√≥digo de barras onde algumas farm√°cias possui o mesmo produto, mas com c√≥digo diferente, algo que n√£o deveria acontecer, o dataframe de produtosVidaia fica dessa forma:
 </p>
 
```python
dfProdutosVidaia = pd.DataFrame({
    'id' : range(√öLTIMO ID CADASTRADO NA TABELA PRODUTOS VIDAIA, √öLTIMO ID CADASTRADO NA TABELA PRODUTOS VIDAIA + len(consulta_produtos_vidaia)),
    'nome': consulta_produtos_vidaia[''],
    'codigoDeBarras1': consulta_produtos_vidaia[''],
    'codigoDeBarras2': consulta_produtos_vidaia[''],
    'codigoDeBarras3': "",
    'dcb': "",
    'categoria': consulta_produtos_vidaia[''],
    'nomeClasse': consulta_produtos_vidaia[''],
    'nomeGrupo': consulta_produtos_vidaia[''],
    'fabricante': consulta_produtos_vidaia[''],
    'valor': consulta_produtos_vidaia[''],
    'codigoProduto': consulta_produtos_vidaia[''],
    'custo': consulta_produtos_vidaia[''],
    'comissao' : consulta_produtos_vidaia[''],
    'updatedAt' : datetime.now()
})
```

<blockquote style="background-color: rgba(255, 0, 0, 0.8); color: white; padding: 10px; border-radius: 10px;">
    <b>OBS: OBSERVE A COLUNA "ID" DE PRODUTOSVIDAIA, ESSA COLUNA DEVE SER UM RANGE DE DADOS QUE INICIA NO ID DO √öLTIMO REGISTRO DE PRODUTOSVIDAIA NO NOSSO BANCO DE CRM E TERMINA NO TABAMNHO TOTAL DO DATAFRAME</b>
</blockquote>

explicando melhor esse ID, basta ir no nosso banco do CRM, entrar na tabela produtosVidaia, ordenar o ID por ordem decrescente e trocar a palavra "substituir" abaixo pelo n√∫mero do maior id+1: 

```python
range(substituir, substituir + len(consulta_produtos_vidaia))
```
![SQL SPA](README_ASSETS/produtos_vidaia.png)

observando a imagem acima, vemos que o maior ID filtrado seria 278388, ent√£o o valor a ser substituido seria **278389**:

```python
range(278389, 278389 + len(consulta_produtos_vidaia))
```
essa adapta√ß√£o no c√≥digo far√° com que voc√™ consiga subir um produto novo sem erro de ID repetido ou coisa assim. Observe tamb√©m que a tabela produtosVidaia n√£o possui todas as colunas presentes no dataframe, isso √© porque o dataframe produtos "herda" o dataframe de produtosVidaia, mas as colunas extras s√£o exlu√≠das l√° embaixo na fun√ß√£o subir_para_base():

```python
dfProdutosVidaia.drop(columns=['valor','codigoProduto', 'custo', 'comissao']).to_sql('produtosVidaia', engine, index=False, if_exists='append', method='multi', chunksize=1000)
```


<h6>Produtos</h6>
<p style="text-align: justify;">
Como mencionado anteriormente, essa tabela basicamente "herda" o dataframe de produtosVidaia e exclui algumas colunas, o dataframe final fica:
</p>

```python
dfProdutos = pd.DataFrame({
    'idProdutoVidaia' : dfProdutosVidaia['id'],
    'nome': dfProdutosVidaia['nome'],
    'codigoDeBarras': dfProdutosVidaia['codigoDeBarras1'],
    'codigoDeBarras2': dfProdutosVidaia['codigoDeBarras2'],
    'fabricante': dfProdutosVidaia['fabricante'],
    'categoria': dfProdutosVidaia['categoria'],
    'valor': dfProdutosVidaia['valor'].astype('float'),
    'usuarioId': usuario_id,
    'codigoProduto': dfProdutosVidaia['codigoProduto'],
    'custo': dfProdutosVidaia['custo'],
    'comissao' : dfProdutosVidaia['comissao'],
    'updatedAt' : datetime.now()
    })
```

<h6>Vendas</h6>
<p style="text-align: justify;">
Vendas segue um padr√£o em todoso os ERP's, ap√≥s o dataframe ser criado com sucesso, √© feita uma agrega√ß√£o por desconto, quantidade e valorVenda, isso porque alguns registros est√£o duplicados, ou seja, na mesma numVenda o cliente X comprou o produto X, uma quantidade, com o valor X e desconto X, ent√£o juntando tudo ficaria cliente X, produto X, quantidade 2X, valor 2X, desconto 2X.
</p>

```python
dfVenda = pd.DataFrame({
    "codigoVenda" : consulta_vendas['numvenda'],
    "usuarioId" : usuario_id,
    "codigoProduto" : consulta_vendas['cod_prod'],
    "data" : pd.to_datetime(consulta_vendas['data']),
    "quantidade" : consulta_vendas['qt_ven'].astype(int),
    "valorVenda" : consulta_vendas['vlr_ven'],
    "desconto" : consulta_vendas['vlr_desc'],
    "codigoCliente" : consulta_vendas['cliente'].astype(str),
    'updatedAt' : datetime.now(),
    "Vendedor": consulta_vendas['atendente'].astype(str)
    })
dfVenda = dfVenda[dfVenda['codigoProduto'] != 0]
dfVenda = dfVenda.groupby(dfVenda.columns.difference(['desconto', 'quantidade', 'valorVenda']).tolist(), as_index=False).agg({
    'desconto': 'sum',
    'quantidade': 'sum',
    'valorVenda': 'sum'
})
```

<p style="text-align: justify;">
Ap√≥s isso, √© verificado todos os clientes que n√£o est√£o presente na tabela clientes e todos os produtos que n√£o est√£o na tabela produtos, essa verifica√ß√£o √© salva em um novo dataframe limpo, assim n√£o teremos erro de clientes/produtos n√£o existentes na hora de subir pra base:
</p>

```python
clientes_nao_encontrados = dfVenda[~dfVenda['codigoCliente'].astype(str).isin(dfClientes['codigoCliente'].astype(str))]
produtos_nao_encontrados = dfVenda[dfVenda['codigoProduto'].astype(str).isin(consulta_produtos['codigo'].astype(str))]
produtos_nao_encontrados.to_csv("produtos_nao_encontrados.csv")
clientes_nao_encontrados.to_csv("clientes_nao_encontrados.csv")

vendas_filtradas = dfVenda[dfVenda['codigoCliente'].astype(str).isin(dfClientes['codigoCliente'].astype(str)) & 
                    dfVenda['codigoProduto'].astype(str).isin(consulta_produtos['codigo'].astype(str))]
vendas_filtradas = vendas_filtradas.drop_duplicates(subset=["usuarioId", "codigoVenda", "codigoProduto"])
vendas_filtradas.to_csv('vendas_filtradas.csv', index=False)
```

<h6>Subir para base</h6>
<p style="text-align: justify;">
a fun√ß√£o subir_para_base basicamente pega todos os dataframes j√° tratados e sobe um por um para o banco CRM, acho que √© bem intuit√≠vo o c√≥digo:
</p>

```python
user = os.getenv('user_vidaia')
password = os.getenv('password_vidaia')
host = os.getenv('host_vidaia')
database = os.getenv('database_vidaia')
port = os.getenv('port_vidaia')

try:
    conn_str = f'postgresql://{user}:{password}@{host}:{port}/{database}'
    engine = create_engine(conn_str)
    try:
        dfClientes.to_sql('clientes', engine, index=False, if_exists='append', method='multi', chunksize=1000)
        print("clientes up com sucesso!")
    except Exception as e:
        print('n√£o foi poss√≠vel subir os dados de clientes', e)
    try:
        dfProdutosVidaia.drop(columns=['valor','codigoProduto', 'custo', 'comissao']).to_sql('produtosVidaia', engine, index=False, if_exists='append', method='multi', chunksize=1000)
        print("produtosVidaia up com sucesso!")
    except Exception as e:
        print('n√£o foi poss√≠vel subir os dados de produtosVidaia', e)
    try:
        dfProdutos.to_sql('produtos', engine, index=False, if_exists='append', method='multi', chunksize=1000)
        print("produtos up com sucesso!")
    except Exception as e:
        print('n√£o foi poss√≠vel subir os dados de produtos', e)
    try:
        dfVendas.to_sql('vendas', engine, index=False, if_exists='append', method='multi', chunksize=1000)
        print("vendas up com sucesso!")
    except Exception as e:
        print('n√£o foi poss√≠vel subir os dados de vendas', e)

except FileNotFoundError:
    print(f"Arquivo de configura√ß√£o 'conf.json' n√£o encontrado.")
    return {}
```

<h4> PRINCIPAIS DIFICULDADES </h4>

<p style="text-align: justify;">
Sem sombra de d√∫vidas, a extra√ß√£o dos dados √© a parte mais complicada, com exce√ß√£o do SPA e LINX, os demais clientes precisam realizar manualmente a obten√ß√£o dos relat√≥rios, algo muito dificultoso pois custa tempo e deixa uma das m√°quinas da farm√°cia indispon√≠vel enquanto o processo √© feito. O principal motivo desse processo ser feito dessa forma √© a falta de interesse por parte dos ERP's de disponibilizar o acesso direto ao banco de dados, at√© mesmo aqueles que disponibilizam n√£o oferecem nenhum tipo de suporte referente a visualiza√ß√µes ou cruzamento de tabelas, √© tudo da nossa parte. O pr√≥ximo passo para solucionar esse problema seria justamente fechar algum tipo de parceria com cada ERP, possibilitando o acesso aos dados de forma remota atrav√©s de um banco de dados com um IP fixo e cedendo credenciais com poder de consulta para a vidaia.
</p>

<h4> PR√ìXIMOS PASSOS </h4>

<p style="text-align: justify;">
Ainda h√° muitas lacunas a serem preenchidas, a mais cr√≠tica seria a comunica√ß√£o cliente/vidaia, essa automa√ß√£o ainda n√£o est√° 100% concluida, ent√£o a alimenta√ß√£o constante dessa base ainda depende de uma etapa humana na maior parte dos casos, outro problema a ser resolvido seria a tabela produtosVidaia que ainda n√£o est√° totalmente estruturada, hoje utilizamos uma "gambiarra", mas que pode ser consertada no futuro.
</p>